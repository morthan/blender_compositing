Кодеки
~~~~~~

Последовательности хороши, они сохраняют качество и быстро обрабатываются. Но во
многих случаях удобнее пользоваться одним файлом, а не тысячами. Процедура
преобразования последовательности в единый файл называется 'кодированием' видео,
а обратный процесс -- 'декодированием'. Программа же, умеющая кодировать и
декодировать, называется 'кодеком' (от английского 'coder/decoder').

Кодеки бывают разные, под разные потребности и с разными характеристиками. По
аналогии с форматами изображений, видеокодеки бывают с потерей качества и без
оных потерь.

Кодеки без потерь качества (так называемые 'lossless-кодеки') простыми людьми
используются редко, ибо сохранение качества при таком размере файла мало кому
требуется. Но они существуют, к примеру Huffyuv и Alparysoft Lossless Video
Codec. Здесь мы их рассматривать не будем, ибо Blender не обладает их встроенной
поддержкой.

[NOTE]
Кроме кодеков, встроенных в сам Blender, в его Windows-версии могут
использоваться кодеки, установленные в системе. Для этого при выборе формата
рендеринга следует выбирать пункт *AVI Codec*, после чего настраивать нужный
кодек в появившемся окне. Эта возможность предназначена для людей, которые
знают, что делают. Бывали случаи, когда неопытные пользователи кодировали видео
каким-нибудь экзотическим кодеком, а потом удивлялись, отчего же оно не
воспроизводится на соседской машине?

Кодеки с потерей качества привычны всем, поскольку дают хорошую степень сжатия и
поддерживаются не только компьютером, но и бытовой техникой. Дешёвые китайские
DVD-проигрыватели уже умеют воспроизводить всё подряд, так что можно не
беспокоиться, что фильм, кодированный DivX, не будет воспроизводиться у вашего
другаfootnote:[К сожалению, это касается только 'дешёвыхъ' китайских
проигрывателей. Некоторые дорогие проигрыватели умеют показывать 'только'
DVD-формат, причём диск должен быть лицензионным. Пиратские диски и самодельные
ролики с возмущением выплёвываются. Спрашивается: зачем же платить больше?].

Как же реализуется сжатие с потерями?

Простейший вариант -- сжать каждый кадр JPEG-ом и склеить всё это в одну большую
кучу. Этот подход используется в форматах DV (видеокамеры) и MJPEG
(фотоаппараты). Связано это с тем, что эти устройства должны работать в реальном
времени и обеспечивать минимальные потери качества (дополнительно испортить
фильм пользователь успеет всегда).

Разумеется, размер у такого файла будет как минимум не менее, чем у аналогичной
последовательности JPEG-ов (а ведь ещё заголовок добавляется!). Как с этим можно
бороться? С помощью использования 'ключевых кадров'.footnote:[По-английски
'keyframes'. Этот принцип используется, в частности, в анимационной системе
Blender. Подробности будут в главе, посвящённой анимации.]

Кадры видео похожи друг на друга и отличаются только в тех местах, где что-то
движется. Было бы неплохо хранить ключевые кадры, содержащие всё изображение,
скажем, через каждую секунду, а промежуточные каким-то образом вычислять, исходя
из имеющихся ключевых кадров. Это было реализовано следующим образом.

Ключевые кадры начали обозначать буквой *I* (от английского выражения 'Intra
pictures'). Они являются отправной точкой, откуда кодек начинает плясать дальше,
вставляя промежуточные *P-кадры* ('Predicted pictures' -- предсказанные
картинки).

Эти кадры хранят отличия данного кадра от предыдущего. Поскольку чаще всего в
кадре что-то движется на фоне неподвижного фона, то размер этих различий
'значительно' меньше размера всего изображения.

P-кадры строятся на основе предыдущего ключевого кадра. Но кадры во второй
половине отрезка между двумя ключевыми кадрами больше похожи не на предыдущий, а
на следующий ключевой кадр! Так появились *B-кадры* ('Bi-directional
pictures' -- двунаправленные картинки), ссылающиеся не на предыдущий I-кадр, а
на два ближайших соседних I- или P-кадра.

В таком виде система и стабилизировалась. Правильный подбор параметров
использования кадров разных типов позволяет добиться приемлемого качества при
хорошем сжатии.

include::section3_3_1.txt[]

include::section3_3_2.txt[]
